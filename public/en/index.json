[
{
	"uri": "/en/introduction/",
	"title": "Introduction",
	"tags": [],
	"description": "",
	"content": " If you know the concept and CI/CD and CodeSeries, junp to Step 2 (lab environment) .\n    Name contents     master Production Code or Production-ready Code   develop Integration Branch, development progress    The lab environment consists of two branches, master and develop. Each branch consists of a build and deployment environment using Code Pipeline. Growing to the develop branch commit are immediately deploying to the development environment, while grow to master branch commit are immediately deploying to the production environment.\nTherefore, the code review and unit test results is very important when merging to master branch. This should be able to be immediately delivered to the developer.\nThis lab covers visualizing the results of the automated unit test with CodeBuild when diff in develop are merged into master. And using CodeGuru to show you how to code review automated in pull-request.\n Now, I will explain the concepts of CI/CD and the services to be used in the lab.   "
},
{
	"uri": "/en/introduction/cdci/",
	"title": "CI/CD with Code Series",
	"tags": [],
	"description": "",
	"content": "Waht is CI/CD?(Continuous Integration/Continuous Delivery) CI / CD is a way to automate build and test to deliver applications to customers in shorter cycles. It is also a solution to solve various problems caused by the merge of idff codes that developers change. CI/CD primarily refers to the build or integration phase during the software release process, and provides automation and monitoring throughout the application lifecycle.\nCI (Continuous Deployment) means that changes from developers are automatically uploaded to Repository after bug testing. CD (Continuous Deployment) means that the developer\u0026rsquo;s changes are all tested and automatically released to the production environment delivery to the customer. As a result, CI/CD means the actual process represented by the pipeline and adds automation monitoring of application development.\nThis allows developers to test their code with minimal effort, or even to actual release. For this reason, a well-formed CI/CD pipeline can improve code quality due to automated tests set on the pipeline, while speeding up the development cycle and improving overall development speed.\nHow? What should I use? You can use the AWS ode Series. Code series is a fully managed service, so there is no need for a infrastructure.  CodeCommit: AWS CodeCommit is a fully-managed source control service that hosts secure Git-based repositories. CodeBuild: AWS CodeBuild is a fully managed continuous integration service that compiles source code, runs tests, and produces software packages that are ready to deploy. CodeDeploy: AWS CodeDeploy is a fully managed deployment service that automates software deployments to a variety of compute services such as Amazon EC2, AWS Fargate, AWS Lambda, and your on-premises servers. CodePipeline: AWS CodePipeline is a fully managed continuous delivery service that helps you automate your release pipelines for fast and reliable application and infrastructure updates.  -and.. What is UnitTest?  "
},
{
	"uri": "/en/introduction/unittest/",
	"title": "Unit Test",
	"tags": [],
	"description": "",
	"content": "What is Unit Test? UnitTest is a Module that tests another Module. software is composed of several modules, and UnitTest means minimum level test unit that can test whether each of these modules functions normally. This workshop will perform UnitTest using Junit in JAVA.\nAnd Developer will visualize it with CodeBuild report group to JUnittest`s result in xml. Developers can easily see what percentage of their tests succeeded or which tests failed.\n-Now let`s take a look at CodeGuru. "
},
{
	"uri": "/en/introduction/codeguru/",
	"title": "CodeGuru",
	"tags": [],
	"description": "",
	"content": "AWS CodeGuru Amazon CodeGuru is a machine learning service for automated code reviews and application performance recommendations. It helps you find the most expensive lines of code that hurt application performance and keep you up all night troubleshooting, then gives you specific recommendations to fix or improve your code. codeGuru supports JAVA. Repository can use GitHub or CodeCommit. It is also easy to integrate.\nCodeGuru\u0026rsquo;s service is composed of two types.\n1. CodeGuru Reviewer that provides Automated CodeReviwe Amazon CodeGuru Reviewer finds issues in your code and recommends how to remediate them.\nThe contents that CodeGuru Reviewer detects can be this categories.\n AWS Best Practices : AWS APIs contain a rich set of features to ensure performance and stability of software. Concurrency : CodeGuru Reviewer identifies problems with implementations of concurrency in multithreaded code Resource Leaks : CodeGuru Reviewer looks for lines of code where resource leaks might be occurring. Sensitive Information Leak : Sensitive information in code should not be shared with unauthorized parties..  2. CodeGuru Profiler Amazon CodeGuru Profiler is always searching for application performance optimizations, identifying your most expensive lines of code and recommending ways to fix them to reduce CPU utilization, cut compute costs, and improve application performance.\n Now let`s get ready for the this lab.   "
},
{
	"uri": "/en/",
	"title": "Home",
	"tags": [],
	"description": "",
	"content": "AWS CI/CD pipeline with CodeGuru \u0026amp; UnitTest to improve code quality  This workshop explains how to build a CI/CD pipeline using AWS\u0026rsquo;s Code Serise. It also explains how to organize various ways to improve code quality (CodeReview \u0026amp; UnitTest) in the AWS pipeline.\nIt covers simple branch build and deployment, UnitTest report, and CodeGuru which automatically performs code review when create pull-requests.\n-Build a CD/CI pipeline to improve code quality using a variety of AWS services!  "
},
{
	"uri": "/en/setup/",
	"title": "Setup",
	"tags": [],
	"description": "",
	"content": " The CloudFormation`s stack created in the next chapter includes all infrastructure and the CI/CD pipeline of master and develop.\n This lab include how to improve your code quality using AWS services. developers can commit, test, and deploy code with minimal effort. The deployment and testing environment is automated.\ninfrastructure Service    Name contents     CodeCommit this is code repository, the development code is JAVA and Gradle.   CodeBuild The build tool is CodeBuild. It using Junit for UnitTest and the result is report to xml. The printed report can be viewed directly from the console using CodeCommit\u0026rsquo;s report group.   CodeDeploy Tested code is automatically deployed to the Dev environment. The code pushed to the Develop Branch is deploy to the DevWebApp01 instance and starts profiling by CodeGuru\u0026rsquo;s profiler. And when all tests pass and merge into Master, the code is automatically deployed as ProdWebApp01.   CodePipeline Visualize the series of steps above as CodePipeline. Developers can immediately find out where the pushed code has a problem.   CodeGuru When Pull-Request, Code-Review is automatically performed. Profiling of the code deployed on DevWebapp01, ProdWebapp01.    -let`s set up the lab environment using CloudFomration. "
},
{
	"uri": "/en/setup/lab-setup/",
	"title": "CloudFormation",
	"tags": [],
	"description": "",
	"content": "AWS Account  If you already have an AWS account, you can immediately follow the this lab, but If you don\u0026rsquo;t have an account, you need to create an AWS account first.\n For an AWS account creation and activation guide, visit this link link For practice, select us-west-2 (Oregon) region. This lab will not work in other AWS Regions Before starting this lab, the resources required for this lab are configured using AWS CloudFormation, and then CodeGuru and Codebuild Report are configured.\n IAM User If you have created an AWS account but have not created an IAM user, you can create an IAM user using the IAM console. Follow the steps below to create an Administrator user. If you already have an admin user, skip the next IAM user creation task.\n Sign in to the IAM Console as the Root user in your AWS account using your AWS account email address and password. Select Users from the menu panel on the left side of the IAM console, then click Add user. Enter User name as Administrator. Select the AWS Management Console access checkbox, select Custom password, and enter your password. Click Next: Permissions.   Select Attach existing policies directly, select the checkbox for the AdministratorAccess policy, and click Next: Tags.   Click Next: Review. Verify that the AdministratorAccess managed policy has been added to the Administrator user, and click Create user. Now, logout the user logout and login as the newly created Administrator user. You can log in using the following URL:   https://\u0026lt;your_aws_account_id\u0026gt;.signin.aws.amazon.com/console/\n\u0026lt;your_aws_account_id\u0026gt; is the unique ID of your AWS account. As a root user, an error may occur when performing this exercise.\n  EC2 Key Pair To configure the basic environment required for the lab using the CloudFormaton template, you must provide an Amazon EC2 key pair. If you already have an EC2 key pair, skip the next task.\n Sign in to the AWS console as a Administrator user, and then go to the EC2 Console (https://console.aws.amazon.com/ec2/). In the navigation pane, select Key Pairs from Network \u0026amp; Security. Click Create Key Pair. Enter the name of the new key pair in Key pair name, then click Create. Private Key file in .PEM file format is automatically downloaded from the browser. The private key is required when using the following CloudFormation.  CloudFormation Template Create a CloudFormation stack using the CloudFormation-template provided to proactively create the AWS resources needed for the AWS AWS CodeQuality lab. Create EC2 and VPC for development and production environments, and CodePipeline, CodeBuild, CodeDeploy, and CodeCommit to live in each environment.\nTo launch the CloudFormation stack, click the Launch Stack button to go to the CloudFormation console.\nImportant: This template was created for us-west-2 (Oregon) and does not work in other AWS Regions.\n  Launch Stack  In the stack creation step, enter a stack name and choose the EC2 key pair you created before. And in the final step, select Acknowledge checkbox and click Create stack so that CloudFormation can use a custom name when creating the IAM resource.\nIt takes about 5 minutes to complete the CloudFormation stack. Check the CloudFormation console and wait for the CREATE_COMPLETE status as shown below. When the stack creation is complete, your AWS account has all the basic resources needed to run the lab. Outputs tab, the name of DevWebApp01 and the name of ProudWebApp01 are displayed.\n -Now let`s build the CI/CD pipeline in the created build environment. "
},
{
	"uri": "/en/setup/cloud9/",
	"title": "Cloud9",
	"tags": [],
	"description": "",
	"content": " Ad blockers, javascript disablers, and tracking blockers should be disabled for the cloud9 domain, or connecting to the workspace might be impacted. Cloud9 requires third-party-cookies. You can whitelist the specific domains.\n Navigate to the Cloud9 console: Navigate to the Cloud9 console: https://console.aws.amazon.com/cloud9\nCreate a workspace Once you navigate to the Cloud9 console, click on the create environment button:   Enter CodequalityWorkshop's Cloud9 to the Name and for Workshop to the Description, and then click Next Step.   Configure settings without changing anything, select Next step.   Select Create Environment.   Finish!   -Now setting CodeCommit for the lab. "
},
{
	"uri": "/en/setup/codecommit/",
	"title": "CodeCommit",
	"tags": [],
	"description": "",
	"content": "CodeCommit Setup and source code download AWS CodeCommit is a fully managed source control service that hosts secure Git-based repositories. This service allows multiple teams to collaborate on code in a secure, highly scalable ecosystem. Since the actual work code is on Github, we will start moving this code to your CodeCommit Repository.\n  let`s set up the code in Cloud9. Enter the following command in the terminal of Cloud9.\ngit clone https://github.com/sykang169/ConcurrencySample.git\r  If the command is executed successfully, created a folder name concurrencysample in the file cloud9 file tree.   clone gets the master branch. If you look at the contents of the folder, there are no other files except the README.md file. the real source code in develop, pull the develop branch.\ncd ConcurrencySample\rgit checkout origin/develop -b develop\r  You can see that a lot more files were created than the master. Now we will change the master and develop code to the codecommit\u0026rsquo;s concurrencysample repository, which we created before in cloudformation stack.\t  To check the output of CloudFormation, go to the CloudFormation console.\ngo to the CloudFormation console : https://console.aws.amazon.com/CloudFormation\n  Select Stacks from the left menu and select CodeQuality-Workshop you created. You can check the detailed information of the stack created here.   Select Outputs at the top of the stack details. There you copy the URL of CodeCommit that lab `a repository.   back to Cloud9. Check the url of the current origin in the previously created concurrencysample folder.\ngit remote show origin\rEnter the command, you cant show the url of the currently set origin.\nremote origin\rFetch URL: https://github.com/sykang169/ConcurrencySample.git\rPush URL: https://github.com/sykang169/ConcurrencySample.git\rHEAD branch: master\rRemote branches:\rdevelop tracked\rmaster tracked\rLocal branches configured for \u0026#39;git pull\u0026#39;:\rdevelop merges with remote develop\rmaster merges with remote master\rLocal refs configured for \u0026#39;git push\u0026#39;:\rdevelop pushes to develop (up to date)\rmaster pushes to master (up to date)\rChange the url of origin to the address of the newly created codecommit at https://github.com/sykang169/ConcurrencySample.git.\nEntering the following in the terminal of Cloud9. \u0026lt;YOUR_REPOSITORY-URL\u0026gt; is the chagne CodeCommit copied from the Stack of CloudFormation.\ngit remote set-url origin \u0026lt;YOUR-REPOSITORY-URL\u0026gt;\rAfter finished the command, check again with git remote show origin, and you can see that the URL of origin has been changed to your CodeCommit address.\nFetch URL: \u0026lt;YOUR_REPOSITORY-URL\u0026gt;\rPush URL: \u0026lt;YOUR_REPOSITORY-URL\u0026gt;\rHEAD branch: master\rRemote branches:\rdevelop tracked\rmaster tracked\rLocal branches configured for \u0026#39;git pull\u0026#39;:\rdevelop merges with remote develop\rmaster merges with remote master\rLocal refs configured for \u0026#39;git push\u0026#39;:\rdevelop pushes to develop (up to date)\rmaster pushes to master (up to date)\r  Now, we will push the code of Cloud9 to the changed CodeCommit Repository. First checkout to master and then push. CodeCommit\u0026rsquo;s Repo doesn\u0026rsquo;t have a any push yet, so the branch that was created first becomes the default branch. so you need to push master first.\ngit checkout master\rgit push\rPush develop in the same way.\ngit checkout develop\rgit push\r  -Now let`s connect CodeGuru to CodeCommit. "
},
{
	"uri": "/en/setup/codeguru-reviewer/",
	"title": "CodeGuru Reviewer",
	"tags": [],
	"description": "",
	"content": "CodeGuru Reviewer setup. go to the CodeGuru console : https://console.aws.amazon.com/codeguru\n  Select Associated repositories from Reviewer on the left menu.   Select Associate repository at the top right.   Select AWS CodeCommit as the Source provider for Repository details, then select concurrencysample at Repository location. and click Associate.   Check the connected concurrencysample in Codeguru\u0026rsquo;s Dashboard.   CodeGuru and CodeCommit are linked.\n  -Now let`s connect CodeGuru Profiler to CodeCommit.  "
},
{
	"uri": "/en/setup/codeguru-profiler/",
	"title": "CodeGuru Profiler",
	"tags": [],
	"description": "",
	"content": "CodeGuru Profiler setup. go to the CodeGuru console: https://console.aws.amazon.com/codeguru\n  Select Profiling groups from Profiler on the left menu.   Select Create profiling groups at the top right.   Enter concurrencysample-profiler in Name of Profiling group details in Create profiling group. click Create at the bottom right.   Enter CodeQuality-Workshop-WebAppRole in choose users and roles in the Manage permissions for concurrencysample-profiler box. Select the checkbox on the left and click Save to save.   Profiler can be found in the main of the source code, ConcurrencyCheckout.java.\npublic static void main(final String[] args) {\r// Start the profiler\r Profiler systemProfiler = Profiler.builder()\r.profilingGroupName(\u0026#34;concurrencysample-profiler\u0026#34;).build();\rsystemProfiler.start();\r...\r}\rIf you want to link to a different report group, please specify concurrencysample-profiler, the parameter of profilingGroupName, with a different report group name.\n  The connection between the CodeGuru Profiler and the instance is now complete.\n   create a report group of CodeBuild finished. let`s setup for easily see the results of Unit Test.    "
},
{
	"uri": "/en/setup/codebuild/",
	"title": "CodeBuild Report",
	"tags": [],
	"description": "",
	"content": "Let`s Add to CodeBuild Report Group this lab use unit tests are using Junit. The result of the unit test is published in xml, and the developer should be able to use this to know which unit test his code did not pass.\nGo to the Codebuild console : https://console.aws.amazon.com/codebuild\n  Select Report groups in the right Build tab. Select Create report group at the top right.   Enter Concurrency-Unittest-Report in Report group name of Rport group configuration. Uncheck the box for Export to Amazon S3.   To copy the ARN of the report groups, Concurrency-Unittest-Report from Report groups.   The results of the Unittest here will now be shown. Copy the contents of Report group ARN of Configuration.   Now lets go back to **Cloud9** and edit **buildspec.yml**. **buildspec.yml** is located in ConcurrencySample's root directory. ![DataLakeStorage03](/images/cloudbuild-report-cloud9.png)\rDouble-click the file to add content. Paste the **Report group ARN** to `.\nreports:\r\u0026lt;YOUR-REPORT-GROUP-ARN\u0026gt;:\rfiles:\r- \u0026#39;**/*\u0026#39;\rbase-directory: \u0026#39;build/test-results/test\u0026#39;\r  this is final code of buildspec.yml.\nversion: 0.2\rphases:\rinstall:\rruntime-versions:\rjava: corretto11\rcommands:\r- java -version\r- gradle -version\rbuild:\rcommands:\r- ./gradlew clean build\rreports:\r\u0026lt;YOUR-REPORT-GROUP-ARN\u0026gt;:\rfiles:\r- \u0026#39;**/*\u0026#39;\rbase-directory: \u0026#39;build/test-results/test\u0026#39; artifacts:\rfiles:\r- \u0026#39;**/*\u0026#39;\rname: concurrencysample-$(date +%Y-%m-%d)   Commit and push them to codecommit.\ncd ConcurrencySample\rgit add .\rgit commit -m \u0026#34;change Buildspec.yml\u0026#34;\rgit push\r  let`s check if the changes have been reflected. Select concurrencysample by selecting Build projects in Build on the left menu.   You can see the failed build. lets click on the content to confirm.\r![codebuild02](/images/codebuild-report-buildfail.png)\rIf you look at the message below, you can see that the build was successful. But you can see UnitTest failed.\r![codebuild02](/images/codebuild-report-unittestfail.png)\rIn this way, it is difficult to see the details of how and what tests have passed. so you can see to the report file generated in the build folder or view the xml file. But you can easily check the results of each build by using the previously linked **CodeBuild Report**.\rlets go Report groups and check the uploaded report.\n  Select Report groups from the left Build menu. Then select the Cuncurrency-Unittest-Report you created earlier.   You can see the success and execution time in a graph and click the report in the report history at the bottom to see the details of UnitTest. It is much more easy to check than the console.   -Let`s see why the unit test failed and how to fix it. "
},
{
	"uri": "/en/codequality/",
	"title": "Program Code",
	"tags": [],
	"description": "",
	"content": " Read this chapter to find out the cause of the detailed source code error. If you want to skip, directly go to solution.. .\n let`s look at the code first. ConcurrencySample Code is written in Java, Gradle.\n This code has a problem.\n   This is the structure of the source code.\n-src\r-main/java/com/example/\r-restservice\r-BasicSynchronization.java\r-ConcurrencyCheckout.java\r-SingletonRepo.java\r-s3\r-AwsCredentials-sample.propertie\r-AWSFileMapper.java\r-FileMapper.java\r  let\u0026rsquo;s take a look at the SingletonRepo file. SingletonRepo can only have one instance in the program. And sigletonsrepo have one HashMap. let\u0026rsquo;s look at the putKey() function, which is the core of this class and lab.\npublic Object putKey(int product_code, int product_price, int tname) { if (map.containsKey(product_code)) {\rreturn map.get(product_code);\r}else{\rreturn map.put(product_code, new Concurrency(product_code,\u0026#34;test\u0026#34;));\r}\r}\rputKey works is simple. Check that HashMap has a number with containKey() and if not, save the number with put().\n  If the HashMap already has the same value, don\u0026rsquo;t put it.   BasicSynchronization calls pukey() of SingletonRepo and inserts a randomly generated number between 0 ~ 10000 in 3000 times.\n  ConcurrencyCheckout is Main class. This class creates 5 BasicSynchronizations and starts 5 threads.   this program repeats input to one HashMap by 5 threads.\n   So what is the problem with this program?   This code has a concurrency issue. if it call two PutKey() from two threads at the same time. What will happen? The putkey () of both threads will enter the same number in the HashMap and increment the Call Count.\nif (map.containsKey(product_code)) { return map.get(product_code);\r}else{\rreturn map.put(product_code, new Concurrency(product_code,\u0026#34;test\u0026#34;)); \u0026lt;-----first, second threadn function doing.\r}\r  The number is entered only once, but the call count is increased twice.\n  HashMap is not thread-safe. The code above is dangerous because get and put don\u0026rsquo;t guarantee atomicity.\n  If the number of threads is increased and the number of putkey calls executed simultaneously increases, the result cannot be guaranteed.\n  An error occurs because the same problem appears in the UnitTest being executed. SingletonRepotests, a unit test that is performed, creates 8 threads and raises the count one by one when an input occurs in the HashMap. And after all the work is done, the number of values entered in the HashMap is compared with the number of occurrences. If the values are the same, the number of inputs and the number of HashMaps are the same, so the function worked correctly.\n  However, UnitTest will continue to fail because the current code was programmed without considering concurrency. Of course, if you are very lucky, the test may succeed. However, to prevent this, SingletonRepotests performs the same test 500 times.\n  -So how do you solve this problem? "
},
{
	"uri": "/en/codegurupr/",
	"title": "CodeGuru Reviewer",
	"tags": [],
	"description": "",
	"content": " The final code is deploy to the production environment by merging the code that solved the problem to the master via Pull-Request.\n   The code for production is now complete. The develop branch\u0026rsquo;s code has passed all unit tests, so we will deploy it to the production environment. junier developers usually don\u0026rsquo;t have permission to push directly to the master branch. So, through pull-request, we will go through a code review with a senior developer or a other developer and reflect it in the master. There may be other problems you may not know.\n  Go to the CodeCommit console to create a pull-request.\nGo to CodeCommit: https://console.aws.amazon.com/CodeCommit\n  Select Repositories in Source and click on concurrencysample.   Select Pull requests from Repositories and click Create pull request in the upper right.   Create pull request, Destination set master and Source set develop and click the Compare button.   Enter pr concurrencytest in Title, for workshop in Description, and select Create pull request on the right.   -You have created a pull-request. Now let`s see what happens. "
},
{
	"uri": "/en/codegurupr/solve-awssdk/",
	"title": "CodeGuru AWSSDK",
	"tags": [],
	"description": "",
	"content": "  let`s check what kind of code review has doing in pull-request.(almost wait 5min.)\n  Go to CodeCommit\u0026rsquo;s console: https://console.aws.amazon.com/codecommit   Select Repositories of Source on the left and click concurrencysample.   Select pr-concurrencytest for Pull requests of Repositories in the left source.   If CodeCommit and Repository are connected, the following screen will appear. Select Activity at the top.   The code review comment was attached to the code that I thought had no problems.   Temporary Security Credentials rather than long-term Security Credentials such as AccessKey and SceretKey. CodeGuru tells you how and how to use the AWS SDK secure. These are things that cannot be found in simple unit tests or experience!\n  You can evaluate whether CodeGuru\u0026rsquo;s suggestions are really useful through feedback. These can contribute to better CodeGuru comments.\n  -And.. let`s see more\u0026amp;hellip;. "
},
{
	"uri": "/en/codegurupr/solve-concurrency/",
	"title": "CodeGuru Concurrency",
	"tags": [],
	"description": "",
	"content": "  Scroll down or look up to see another comment. I thought concurrentHashMap was a thread-safe data structure, but there was one problem. ConcurrentHashMap does not lock the entire map when performing put command for performance. Of course, you can declare a function to be synchronized and synchronize, but in this case, it is the same as turning in a single-thread, which can cause performance problems.\n  A more detailed what CodeGuru points out is as follows.\nif (map.containsKey(product_code)) { \u0026lt;-----second function doing...\rreturn map.get(product_code);\r}else{\rreturn map.put(product_code, new Concurrency(product_code,\u0026#34;test\u0026#34;)); \u0026lt;-----first function doing...\r}\r  The result of containsKey() cannot be guaranteed because put() of CuncurrenctHashMap does not lock the entire map. The concurrency problem is a very difficult error to occur if it is a simple code or a small thraed. However, if an error occurs, it will be very difficult to fix the problem if you do not understand the correct behavior of ConcurrentHashMap. CodeGuru can find these problems. It also provides a solution.\n  As suggested by CodeGuru Reviewer, you can guarantee atomicity by performing the putIfAbsent() function once instead of the put() and containsKey(). We will fix the code as follows.\n-if (map.containsKey(product_code)) { - return map.get(product_code);\r-}else{\r- return map.put(product_code, new Concurrency(product_code,\u0026#34;test\u0026#34;));\r+return map.putIfAbsent(product_code, product_price);\r  The full code of singletonRepo.java is here..\npackage com.example.concurrencyservice;\rimport java.text.DateFormat;\rimport java.text.SimpleDateFormat;\rimport java.util.concurrent.*;\rpublic class SingletonRepo {\rprivate ConcurrentHashMap\u0026lt;Integer, Concurrency\u0026gt; map = new ConcurrentHashMap\u0026lt;\u0026gt;();\rDateFormat df = new SimpleDateFormat(\u0026#34;yyyy-MM-dd\u0026#34;);\rprivate static SingletonRepo singletonrepo = null;\rprivate SingletonRepo() {}\rpublic synchronized static SingletonRepo getInstance() {\rif (singletonrepo == null) {\rsingletonrepo = new SingletonRepo();\rSystem.out.println(\u0026#34;singleton repo instance created\u0026#34;);\r// count = 0;\r }\rreturn singletonrepo;\r}\rpublic Object putKey(int product_code, int product_price, int tname) { return map.putIfAbsent(product_code, new Concurrency(product_code,\u0026#34;test\u0026#34;));\r}\rpublic int getMapCount() {\rreturn map.size();\r}\rpublic void clearHashMap() {\rmap = new ConcurrentHashMap\u0026lt;\u0026gt;();\r}\rpublic Concurrency getKey(int product_number) {\rif (!map.containsKey(product_number)) {\rreturn null;\r} else {\rreturn map.get(product_number);\r}\r}\r}\rEdit the code and push.\ngit add .\rgit commit -m \u0026#34;fix put(), containerKey()-\u0026gt; putifAbsent()\u0026#34;\rgit push\r  the problem has been fixed, we will end the Pull-Request. Click the Merg button in the top right corner of the AWS console.   Since master has not changed, we choose Fast forward merge. Source is develop branch, uncheck the box of Delete source branch develop after merging?.   Select Pipeline pipelines from the left menu. Now you can see the build progress as the develop code goes into the master.   After a while, you can see that the master\u0026rsquo;s build and deployment is complete. The newly changed code is safely merge in the production environment.   Using the CD/CI pipeline, modifications of the code can be safely reflected as the master. Also, developers can easily see the test results and process of the code by simply using Commit and push.\n  UnitTest and CodeReview are one of the best ways to improve code quality. For each process, you can use the CodeBuild Report and CodeGuru Reviwer to make code review and UnitTest safer and more effective.\n  -Now let`s check the profiling results that are actually deployed and running. "
},
{
	"uri": "/en/codeguruprofiler/",
	"title": "CodeGuru Profiler",
	"tags": [],
	"description": "",
	"content": "We will create CodeGuru Profiler groups. This is where you can see the data of Profiling.\n  Go to the CodeGuru console: https://console.aws.amazon.com/CodeGuru\n  Select Profiling groups from the Profiler on the left menu. Then select concurrencysample-profiler.   You can see the analysis by CodeGuru Profiler. You can estimate the amount of time, percent, and cost per function. In addition, the results of profiling can be analyzed to provide reports that require improvement.   Overview Visualization   An overview visualization can help you find specific call stacks that lead to inefficient code. You can find code that is running on the CPU by looking for flat tops in the visualization. It is an area where the CPU is doing work directly in that function and not a callee.\n  Inspect Visualization An inspect visualization is useful when you want to analyze a frame that appears in many places. It groups all of the frames with the same name together in the middle of the visualization. Children (callees) are merged and shown above the selected frame. Parents (callers) are merged and shown below the selected frame.\nHotspot Visualization A hotspots visualization can be used to investigate functions that are by themselves computationally expensive. It shows a top-down view of your profile. The functions consuming the most application time are at the top of the visualization. At the bottom of the visualization are the entry point functions.\nRecommendations Report Amazon CodeGuru Profiler makes recommendations you can use to optimize your applications. Each recommendation includes information about why the recommendation was made, a description, suggested resolution steps, and the stack locations that were the source of the recommendation.\nReusing the AWS Client seems to be able to more optimize the program. You can optimize the software using this variety of information.\n-Now that the training is finish!, Let`s delete the resources created. "
},
{
	"uri": "/en/codequality/solve/",
	"title": "Solution",
	"tags": [],
	"description": "",
	"content": "  You can change HashMap to ConcurrenctHashMap. ConcurrenctHashMap is designed to be thread-safe, so it operates stably in a multi-threaded environment and has slightly better performance than Hashtable and synchronized map. ConcurrenctHashMap locks the map when you put it, so you can prevent the same key put at the same time.\n  Open the SingletonRepo.java file in Cloud9.   Change the HashMap below to ConcurrentHashMap.\n+ import java.util.concurrent.*;\r ...\r- private HashMap\u0026lt;Integer, Concurrency\u0026gt; map = new HashMap\u0026lt;\u0026gt;();\r+ private ConcurrentHashMap\u0026lt;Integer, Concurrency\u0026gt; map = new ConcurrentHashMap\u0026lt;\u0026gt;();\r\r...\rpublic void clearHashMap() {\r+ map = new ConcurrentHashMap\u0026lt;\u0026gt;();\r- map = new HashMap\u0026lt;\u0026gt;();\r }\r  The final SingletonRepo.java source code\npackage com.concurrencysample;\rimport java.text.DateFormat;\rimport java.text.SimpleDateFormat;\rimport java.util.Date;\rimport java.util.HashMap;\rimport java.util.concurrent.*;\rimport com.amazonaws.auth.AWSCredentials;\rimport com.amazonaws.auth.AWSStaticCredentialsProvider;\rimport com.amazonaws.auth.BasicAWSCredentials;\rimport com.amazonaws.services.dynamodbv2.AmazonDynamoDB;\rimport com.amazonaws.services.dynamodbv2.AmazonDynamoDBClientBuilder;\rimport com.amazonaws.services.dynamodbv2.document.DynamoDB;\rimport com.amazonaws.services.dynamodbv2.document.Item;\rimport com.amazonaws.services.dynamodbv2.document.Table;\rimport com.amazonaws.services.dynamodbv2.model.AttributeDefinition;\rimport com.amazonaws.services.dynamodbv2.model.CreateTableRequest;\rimport com.amazonaws.services.dynamodbv2.model.KeySchemaElement;\rimport com.amazonaws.services.dynamodbv2.model.KeyType;\rimport com.amazonaws.services.dynamodbv2.model.ProvisionedThroughput;\rimport com.amazonaws.services.dynamodbv2.model.ScalarAttributeType;\rpublic class SingletonRepo {\rprivate static String ACCESS_KEY = \u0026#34;\u0026#34;;\rprivate static String SECERET_KEY = \u0026#34;\u0026#34;;\rprivate ConcurrentHashMap\u0026lt;Integer, Concurrency\u0026gt; map = new ConcurrentHashMap\u0026lt;\u0026gt;();\rDateFormat df = new SimpleDateFormat(\u0026#34;yyyy-MM-dd\u0026#34;);\rprivate static SingletonRepo singletonrepo = null;\rstatic AWSCredentials ac;\rstatic AmazonDynamoDB dynamodb;\rprivate SingletonRepo() {\r}\rpublic synchronized static SingletonRepo getInstance() {\rif (singletonrepo == null) {\rsingletonrepo = new SingletonRepo();\rac = new BasicAWSCredentials(ACCESS_KEY, SECERET_KEY);\rdynamodb = AmazonDynamoDBClientBuilder\r.standard()\r.withRegion(\u0026#34;us-west-2\u0026#34;)\r.withCredentials(new AWSStaticCredentialsProvider(ac) )\r.build();\rSystem.out.println(\u0026#34;singleton repo instance created\u0026#34;);\r}\rreturn singletonrepo;\r}\rpublic Concurrency get(int product_code){\rreturn map.get(product_code);\r}\rpublic Concurrency putKey(int product_code ) { Date date = Util.getRandomDate();\rif (map.containsKey(product_code)) {\rreturn map.get(product_code);\r}else{\rreturn map.put(product_code, new Concurrency(product_code,\u0026#34;test\u0026#34; , date));\r} }\rpublic void delKey(int product_code ) { if (map.containsKey(product_code)) {\rmap.remove(product_code);\r}\r}\rpublic int getMapCount() {\rreturn map.size();\r}\rpublic synchronized void clearHashMap() {\rmap.clear();\rmap = new ConcurrentHashMap\u0026lt;\u0026gt;();\r}\rpublic Concurrency getKey(int product_number) {\rreturn map.get(product_number); }\r}\r  push the changes again.\ngit add .\rgit commit -m \u0026#34;fix singletonrepo.java\u0026#34;\rgit push\r  And if you check the concurrencysample of Build, you can see that the build was successful   let`s also check the Report. If you select Concurrency-Unittest-Report in Report group of Build, you can see the result passed by 100%.   it passed all tests, it was automatically deploy to the dev environment according to Pipeline\u0026rsquo;s process.\n  -Now let`s create a pull-request for deployment code to production environment "
},
{
	"uri": "/en/cleanup/",
	"title": "Clean Up",
	"tags": [],
	"description": "",
	"content": " After completing this lab, you should delete the resources you used to avoid incurring additional charges on your AWS account. To delete a resource, sign in to the AWS Management Console with your existing ** Administrator ** account.\n Clean up all AWS resources created using AWS CloudFormation. Delete any changes made to resources previously created in CloudFormation. Delete the IAM, CodeGuru Profiler Group, CodeGuru Reviewer Associate and CodeBuild Report set for S3 Bucket and CodeGuru where the build results are stored.\n S3  IAM Role  CodeGuru Reviewr  CodeGuru Profiler  CloudFormation  Codebuild Report Group  Cloud9   "
},
{
	"uri": "/en/cleanup/s3/",
	"title": "S3 Bucket",
	"tags": [],
	"description": "",
	"content": "  Go to the S3 console: https://console.aws.amazon.com/s3\n  Enter awsworkshop-concurrencysample-us-west-2 in the search bar of Buckets. Then select the radio button to the right of the retrieved bucket. Then press the Empty button at the top.   To activate the Empty button of the empty bucket, enter the bucket name and press the Empty button to delete all bucket.   When the message that the deletion is complete appears, click Exit on the upper right to complete.   Next delete the IAM role. "
},
{
	"uri": "/en/cleanup/iam/",
	"title": "IAM Role",
	"tags": [],
	"description": "",
	"content": "Delete the IAM role.   Go to the IAM console: https://console.aws.amazon.com/iam\n  Select Roles of Access management on the left Dashboard and search for CodeQuality-Workshop-WebAppRole in the search box. Click the checkbox of the search results and select Delete role.   Select Yes, Delete for Delete role.    let`s delete CodeGuru Reviewer\u0026amp;rsquo;s Associate Repository.   "
},
{
	"uri": "/en/cleanup/codeguru-associate/",
	"title": "CodeGuru Reviewr",
	"tags": [],
	"description": "",
	"content": "Delete CodeGuru Reviewr Associate Repo.   Go to the CodeGuru console: https://console.aws.amazon.com/CodeGuru\n  Select Associated repositories from Reviewer on the left menu.   In Associated repositories, check the radio box of concurrencysample and select Disasociate repository in the Action drop box in the upper right.   If status is changed to Disassociating and then refreshed again, it will not be deleted.\n  Next, delete the CodeGuru Profiler\u0026amp;rsquo;s Profiling Group. "
},
{
	"uri": "/en/cleanup/codeguru-profiler/",
	"title": "CodeGuru Profiler",
	"tags": [],
	"description": "",
	"content": "Delete CodeGuru Reviewr Associate Repo.   Go to the CodeGuru console: https://console.aws.amazon.com/CodeGuru\n  Select Profiling groups from the Profiler on the left menu.   In Profiling groups, check the radio box of concurrencysample-sampler and select Delete profiling group in the** Action** drop box in the upper right.   Select Delete at the bottom of Delete profiling group.   Next, delete the Stack of CloudFormation. "
},
{
	"uri": "/en/cleanup/cloudformation/",
	"title": "CloudFormation",
	"tags": [],
	"description": "",
	"content": "Delete the CloudFormation Stack.   Go to the CloudFormation console: https://console.aws.amazon.com/CloudFormation\n  Select Stacks from the left menu, select the radio button to CodeQuality-Workshop, and select Delete at the top.   In Delete CodeQuality-Workshop?, select Delete stack at the bottom.   Status of CodeQuality-Workshop of Stacks is changed to DELETE_IN_PROGRESS. When finished, it will be deleted from the screen.\n  Now let`s delete CodeBuild Report Group.  "
},
{
	"uri": "/en/cleanup/codebuild/",
	"title": "CodeBuild Report Group",
	"tags": [],
	"description": "",
	"content": "Delete CodeBuild Report Group.   Go to the CodeBuild console: https://console.aws.amazon.com/CodeBuild\n  In Report groups, check the radio box of Concurrency-uniitest-Report and push Delete.   Enter delete in the ** Delete ** window and press the ** Delete ** button! (If it is not deleted, you can delete all the build results inside the scroll.)\n  Next delete Cloud9 "
},
{
	"uri": "/en/cleanup/cloud9/",
	"title": "Cloud9",
	"tags": [],
	"description": "",
	"content": "Delete Cloud9.   Go to the Cloud9 console: https://console.aws.amazon.com/cloud9   Select the radio button for CodequalityWorkshop`s Cloud9 in Your environments and Delete at the top.Â   Enter Delete in Delete Codequalityworkshop\u0026rsquo;s Cloud9 and click the ** Delete ** button.    All data has been deleted! thanks you!! Best Regards  "
},
{
	"uri": "/en/categories/",
	"title": "Categories",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "/en/tags/",
	"title": "Tags",
	"tags": [],
	"description": "",
	"content": ""
}]